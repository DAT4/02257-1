
# 2   Property-Based Testing - Validation of rendering properties
In this section we describe how we test our implementation of designing aesthetically pleasant renderings of trees. We will describe the use of property based testing (PBT) for validating the four aesthetic rules described in Sec. 1. Specifically, we use FsCheck.NUnit for integrating the FsCheck PBT tool into a unit testing framework. In separate subsections, we describe the four different aesthetic rules of the paper and specify how these rules can be described as boolean properties to be tested by FsCheck. First, we briefly describe how property based testing works with the simple case of the 'mean' function.

## 2.1   Simple case - the mean function
PBT concerns describing a property of a feature that should hold for all input and then test this for random input in order to ensure that the property holds for the implementation of the feature. The process is thus

1. Write a boolean function that describes the property
2. Use the FsCheck tool to create random input for the property
3. Run the test that includes the boolean function using the input generated by the FsCheck Tool. When using NUnit for testing purposes, we use the FsCheck.NUnit package that includes the `<Property>` attribute that should be added to the property based tests.

Let us consider the simple example of the mean function implemented as
```fsharp
let mean (x: float, y: float) : float = 
    (x+y)/2.0
```
There are multiple properties that could be tested for this such as bounding properties (e.g. 'mean (x, y) =< max (x, y)' and 'mean (x, y) >= min (x, y)') and the symmetry property ('mean (x, y) = mean (y, x)'). For simplicity, we only implemented the symmetry property as
```fsharp
let meanSymmetryProp (a,b) =
	mean (a, b) = mean (b, a)
```
such that the unit test is 
```fsharp
open FsCheck.NUnit
[<Property(Arbitrary=[|typeof<NormalFloatGenerators>|])>]
let symmetryOfMeanTest () =
    meanSymmetryProp
```
With this we have shown a simple example on how to use PBT and some of the pitfalls of using FsCheck. Notice that in testing the symmetry property, instead of using floats we use the FsCheck type 'NormalFloat' that removes non-normal floats (e.g. 'nan' and 'infinity') from the randomly generated input since e.g. 'nan=nan' would return 'false'. This is done by defining a random value generator which in this case we call `NormalFloatGenerators`. Next we describe how we construct a random tree generator and use this for PBT to validate the implementation of the aesthetic rules that the tree design should obey.

## 2.2   Generators

For the property based test we will need to generate arbitrary trees which are not infinite, and for that we will implement a custom generator 

```fsharp
let tree<'a> =
    let rec tree' s =
        match s with
        | 0 -> Gen.map (fun v -> Node(v, [])) Arb.generate<'a>
        | n when n>0 ->
            let subtrees = tree' (n/2)  |> Gen.sample 0 5 |> Gen.constant 
            Gen.map2 (fun v ts -> Node(v, ts)) Arb.generate<'a> subtrees 
        | _ -> invalidArg "s" "Only positive args are allowed"
    Gen.sized tree'
```

The function `tree'` will recursively generate an arbitrary tree of arbitrary type where each node has between 0 and 5 children nodes. The reason that 5 children is the upper limit, is that the test will be extremely slow with a higher amount.

When testing the data we need to specify a type, because we can't test generic types. So when we implement a type which implements the Arbitrary interface we will specify the type as char.

```fsharp
type TreeGenerator =
    static member Tree() =
        {new Arbitrary<Tree<char>>() with
            override x.Generator = tree<char>
            override x.Shrinker t = Seq.empty }
```

The reason we implement the TreeGenerator as an Arbitrary interface is to register it so that it will be recognized as a valid type when annotating the property based tests.

```fsharp
Arb.register<TreeGenerator>() |> ignore
```


## 2.3   Testing the aesthetic rules
We are now ready for testing the aesthetic rules which is done in the subsequent four subsections. 

### 2.3.1   Rule 1
'Two nodes at the same level should be placed at least a given distance apart.'

In order to test this rule, ew defined a function for flattening a positioned tree by recursively going through the nodes, i.e.

```fsharp
let flatten (t: Tree<'a>) = 
    let rec f d px (PosNode(_, pos, cs)) = (pos+px, d) :: List.collect (f (d+1) (pos+px)) cs 
    f 0 0 (designTree t) |> List.groupBy (fun (_,d) -> d)
                         |> List.map ( fun (_, xs) -> xs |> List.map (fun x -> fst x) )
```
This converts a positioned tree into a list where the index corresponds to the depth in the tree and the element is a list containing the positions of Nodes at that depth. At each depth, we then check that all nodes are at least a unit apart using the function
```fsharp
let minimum_distance_check(t: Tree<'a>) = 
    let isInOrder xs = xs
                       |> Seq.pairwise 
                       |> Seq.forall (fun (a, b) -> a <= b-1.0)
    flatten t |> Seq.forall isInOrder
```
This boolean function is used to describe the property that two nodes on the same level should be at least a given distance apart. 

We note that we do not take the size of the node value into account. As a further requirement, one could include that the values of two nodes at the same level are not allowed to overlap. This could easily be included by finding the maximal size of the values of all the nodes in the tree and scale the tree with this unit, e.g. by altering the unit in the `fit` function. We have left this as an exercise for the reader.


### 2.3.2   Rule 2
'A parent should be centred over its offspring.'

In order to test this rule, for each node, we compare the minimal and maximal positions of the subnodes and assert that the parent is indeed centered above these. Since the positions are relative to the parent this reduce to checking that the maximal position equals minus the minimal position. If this holds, we recursively go through the subtrees to check that it holds throughout the tree, i.e.

```fsharp
let rec centeringProperty (PosNode (_, _, subtrees) as tree ) =
    match subtrees with
    | [] -> true
    | sts ->
        let subtreePositions = subtrees |> List.map getSubtreePositions
        if List.min subtreePositions = - List.max subtreePositions then
            sts |> List.forall centeringProperty
        else
            false
```

This boolean function is used to describe the property that a parent should be centered above its subtrees.

### 2.3.3   Rule 3
'Tree drawings should be symmetrical with respect to reflection — a tree and
its mirror image should produce drawings that are reflections of each other. In
particular, this means that symmetric trees will be rendered symmetrically.'

We test this rule by noting that this corresponds to the symmetry property that changing the sign of the positions of a positioned tree should be the same as finding the positioned tree of a reversed tree. That is, by writing a function that reflect a tree, e.g.

```fsharp
let rec reflect (Node(v, subtrees)) =
    Node(v, List.map reflect (List.rev subtrees))
```
and a function that reflects a positioned tree, e.g.

```fsharp
let rec reflectpos (PosNode(v, x, subtrees)) =
    PosNode(v, -x, List.map reflectpos  (List.rev subtrees))
```
we have the symmetry property that

```fsharp
let symmetryProperty tree =
    designTree tree = reflectpos (designTree (reflect (tree)))
```
This is used to check that the drawings indeed are symmetrical with respect to reflection. 



### 2.3.4   Rule 4
'Identical subtrees should be rendered identically—their position in the larger
tree should not affect their appearance.'

We test this rule by noticing that the `blueprint` function, that creates the positioned tree, recursively goes through the subtrees to first identify the node postions using the extents, then move the trees and extents to the corresponding positions. Due to the recursive nature, we only need to show that the trees are not altered by moving them. We thus define a function to compare the shapes of two trees
```fsharp
let rec compareTreeShapes (tree1 : PosTree<'a>, tree2 : PosTree<'a>) =
    match  (tree1, tree2) with
    | (PosNode(_, _, subtrees1), PosNode(_, _, subtrees2))
        when List.length subtrees1 <> List.length subtrees2 -> false
    | (PosNode(_, x1, subtrees1), PosNode(_, x2, subtrees2)) ->
		let comparePositions (PosNode(_, subtreex1, _)) (PosNode(_, subtreex2, _)) =
			subtreex1 = subtreex2
        List.forall2 comparePositions subtrees1 subtrees2
            && List.zip subtrees1 subtrees2  |> List.forall compareTreeShapes
```

Then the property to be tested can be written as
```fsharp
let movingTreeIsUnalteredProperty x tree =
    compareTreeShapes ((moveTree x tree), tree)
```

In principle, we would have liked to make a black box test by making a function that recursively compared all subtrees of same shape in a tree, but this was left out due to time considerations.
